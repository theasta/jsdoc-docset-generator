var fs = require('fs');
var path = require('path');
var lodashStreamer = require('lodash-template-stream');
var fsx = require('extended-fs');
var Sequelize = require("sequelize");
var Q = require('q');

var INFO_PLIST = 'Info.plist';
var ICON = 'icon.png';
var SQLITE_DB = 'docSet.dsidx';

// @todo transform all sync functions into async operations

var DocSetGenerator = function (config) {
    /**
     * Internal config
     * @type {Object}
     */
    this.config = this._parseConfig(config);
    this.createDocSetFolder();
};

/**
 * @private
 */
DocSetGenerator.prototype.createDocSetFolder = function () {
    if (fs.existsSync(this.getDocSetFullPath())) {
        console.log("Folder " + this.getDocSetFullPath() + " already exists. Deleting it...");
        fsx.rmDirSync(this.getDocSetFullPath());
        console.log("Folder " + this.getDocSetFullPath() + " successfully deleted.");
    }
    this._createFolderStructure();
};

/**
 *
 * @param {*} config
 * @returns {*}
 * @private
 */
DocSetGenerator.prototype._parseConfig = function (config) {
    if (!fs.existsSync(config.docSetRoot)) {
        fsx.mkdirpSync(config.docSetRoot);
    }
    // add / at the end if not already there
    if (config.docSetRoot.lastIndexOf("/") !== config.docSetRoot.length - 1) {
        config.docSetRoot += "/";
    }
    if (!fs.existsSync(config.documentation)) {
        throw Error("Please provide the path to the documentation generated by jsdoc (config: documentation)")
    }
    if (typeof config.docSetName !== 'string' || config.docSetName.trim().length === 0) {
        throw Error("Please pass a valid name for this docSet (config: docSetName)");
    }

    ['docSetIdentifier', 'docSetPlatformFamily'].forEach(function (key) {
        if (typeof config[key] !== 'string' || config[key].trim().length === 0) {
            config[key] = config.docSetName;
        }
    });

    config.docSetFullPath = config.docSetRoot + config.docSetIdentifier + '.docset';

    return config;
};

/**
 * @private
 */
DocSetGenerator.prototype._createFolderStructure = function () {
    fsx.mkdirpSync(this.getDocumentsFolder());
    console.log("Folder Structure " + this.getDocumentsFolder() + " successfully created.");
    this._copyDocumentation();
    this._copyIcon();
    this._createInfoPlist();
    this._createDatabase();
};

/**
 * @private
 */
DocSetGenerator.prototype._createInfoPlist = function () {
    fs.createReadStream(path.resolve(__dirname, '../templates/' + INFO_PLIST))
        .pipe(lodashStreamer(this.config))
        .pipe(fs.createWriteStream(this.getContentsFolder() + INFO_PLIST));
    console.log(INFO_PLIST + " successfully copied to DocSet.");
};

/**
 *
 * @private
 */
DocSetGenerator.prototype._copyIcon = function () {
    var iconPath = this.config.icon;
    if (fs.existsSync(iconPath)) {
        fs.createReadStream(iconPath)
            .pipe(fs.createWriteStream(this.getDocSetFullPath() + '/' + ICON));
        console.log(ICON + " successfully copied to DocSet.");
    } else {
        console.log('No icon specified.');
    }
};


/**
 * @private
 */
DocSetGenerator.prototype._createDatabase = function () {
    var sqliteFilePath = this.getResourcesFolder() + SQLITE_DB;

    this.sequelize = new Sequelize('database_name', 'username', 'password', {
        dialect: 'sqlite',
        storage: sqliteFilePath
    });

    console.log("Database " + SQLITE_DB + " successfully created.");
};

/**
 * Populate the sqlite database
 * @param {Array} entries - Array of search indexes
 * @returns {Promise}
 */
DocSetGenerator.prototype.populate = function (entries) {
    var deferred = Q.defer();

    //sqlite> CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);
    // @todo add unique index
    //sqlite> CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);

    var SearchItem = this.sequelize.define('searchIndex', {
        id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true
        },
        name: Sequelize.STRING,
        type: Sequelize.STRING,
        path: Sequelize.STRING
    }, {
        freezeTableName: true, // otherwise the table is renamed searchIndexes
        timestamps: false
    });

    this.sequelize
        .sync({ force: true })
        .then(function(err) {
            SearchItem.bulkCreate(entries)
                .catch(function (err) {
                    deferred.reject(err);
                })
                .then(function() {
                    deferred.resolve();
                });
        })
        .catch(function(err) {
            deferred.reject(err);
            throw err;
        });

    return deferred.promise;
};

/**
 *
 * @private
 */
DocSetGenerator.prototype._copyDocumentation = function () {
    fsx.copyDirSync(this.config.documentation, this.getDocumentsFolder());
    console.log("jsDoc Documentation successfully copied to " + this.getDocumentsFolder() + ".");
};


/**
 *
 * @returns {string}
 * @private
 */
DocSetGenerator.prototype.getDocSetFullPath = function () {
    return this.config.docSetFullPath;
};

/**
 *
 * @returns {string}
 * @private
 */
DocSetGenerator.prototype.getContentsFolder = function () {
    return this.getDocSetFullPath() + '/Contents/';
};

/**
 *
 * @returns {string}
 * @private
 */
DocSetGenerator.prototype.getResourcesFolder = function () {
    return this.getDocSetFullPath() + '/Contents/Resources/';
};

/**
 *
 * @returns {string}
 * @private
 */
DocSetGenerator.prototype.getDocumentsFolder = function () {
    return this.getDocSetFullPath() + '/Contents/Resources/Documents/';
};

module.exports = DocSetGenerator;
